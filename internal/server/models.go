package server

import (
	"net/http"
	"strings"

	"github.com/n0madic/go-chatmock/internal/codec"
	"github.com/n0madic/go-chatmock/internal/config"
	"github.com/n0madic/go-chatmock/internal/types"
)

const anthropicModelCreatedAt = "2024-01-01T00:00:00Z"

func (s *Server) handleListModels(w http.ResponseWriter, r *http.Request) {
	if isAnthropicRequest(r) {
		s.handleListModelsAnthropic(w, r)
		return
	}

	mods := s.Registry.GetModels()
	var data []types.ModelObject
	for _, m := range mods {
		if m.Visibility == "hidden" {
			continue
		}
		data = append(data, types.ModelObject{ID: m.Slug, Object: "model", OwnedBy: "owner"})
		if s.Config.ExposeReasoningModels {
			for _, lvl := range m.SupportedReasoningLevels {
				data = append(data, types.ModelObject{
					ID:      m.Slug + "-" + lvl.Effort,
					Object:  "model",
					OwnedBy: "owner",
				})
			}
		}
	}
	codec.WriteJSON(w, http.StatusOK, types.ModelList{Object: "list", Data: data})
}

func (s *Server) handleListModelsAnthropic(w http.ResponseWriter, r *http.Request) {
	if !validateAnthropicHeaders(w, r) {
		return
	}

	mods := s.Registry.GetModels()
	data := make([]types.AnthropicModel, 0, len(mods))
	for _, m := range mods {
		if m.Visibility == "hidden" {
			continue
		}
		data = append(data, types.AnthropicModel{
			ID:          m.Slug,
			Type:        "model",
			DisplayName: firstNonEmpty(m.DisplayName, m.Slug),
			CreatedAt:   anthropicModelCreatedAt,
		})
		if s.Config.ExposeReasoningModels {
			for _, lvl := range m.SupportedReasoningLevels {
				id := m.Slug + "-" + lvl.Effort
				data = append(data, types.AnthropicModel{
					ID:          id,
					Type:        "model",
					DisplayName: id,
					CreatedAt:   anthropicModelCreatedAt,
				})
			}
		}
	}

	resp := types.AnthropicModelListResponse{
		Data:    data,
		HasMore: false,
	}
	if len(data) > 0 {
		resp.FirstID = data[0].ID
		resp.LastID = data[len(data)-1].ID
	}
	codec.WriteJSON(w, http.StatusOK, resp)
}

// Ollama model endpoints

func (s *Server) handleOllamaVersion(w http.ResponseWriter, r *http.Request) {
	codec.WriteJSON(w, http.StatusOK, types.OllamaVersionResponse{Version: config.OllamaVersionString})
}

func (s *Server) handleOllamaTags(w http.ResponseWriter, r *http.Request) {
	mods := s.Registry.GetModels()
	var modelList []types.OllamaModelEntry
	for _, m := range mods {
		if m.Visibility == "hidden" {
			continue
		}
		ids := []string{m.Slug}
		if s.Config.ExposeReasoningModels {
			for _, lvl := range m.SupportedReasoningLevels {
				ids = append(ids, m.Slug+"-"+lvl.Effort)
			}
		}
		for _, id := range ids {
			modelList = append(modelList, types.OllamaModelEntry{
				Name:       id,
				Model:      id,
				ModifiedAt: "2023-10-01T00:00:00Z",
				Size:       815319791,
				Digest:     "8648f39daa8fbf5b18c7b4e6a8fb4990c692751d49917417b8842ca5758e7ffc",
				Details: types.OllamaModelDetails{
					ParentModel:       "",
					Format:            "gguf",
					Family:            "llama",
					Families:          []string{"llama"},
					ParameterSize:     "8.0B",
					QuantizationLevel: "Q4_0",
				},
			})
		}
	}
	codec.WriteJSON(w, http.StatusOK, types.OllamaModelList{Models: modelList})
}

func (s *Server) handleOllamaShow(w http.ResponseWriter, r *http.Request) {
	var payload map[string]any
	body, ok := readBody(w, r, s.ollamaEnc)
	if !ok {
		return
	}
	if err := decodeJSON(body, &payload); err != nil {
		s.ollamaEnc.WriteError(w, http.StatusBadRequest, "Invalid JSON body")
		return
	}
	model, _ := payload["model"].(string)
	if model == "" {
		s.ollamaEnc.WriteError(w, http.StatusBadRequest, "Model not found")
		return
	}

	codec.WriteJSON(w, http.StatusOK, types.OllamaShowResponse{
		Modelfile:  "# Modelfile generated by \"ollama show\"\nFROM /models/blobs/sha256:placeholder\nTEMPLATE \"\"\"{{ .System }}\\nUSER: {{ .Prompt }}\\nASSISTANT: \"\"\"\nPARAMETER num_ctx 100000\nPARAMETER stop \"</s>\"\nPARAMETER stop \"USER:\"\nPARAMETER stop \"ASSISTANT:\"",
		Parameters: "num_keep 24\nstop \"<|start_header_id|>\"\nstop \"<|end_header_id|>\"\nstop \"<|eot_id|>\"",
		Template:   "{{ if .System }}<|start_header_id|>system<|end_header_id|>\n\n{{ .System }}<|eot_id|>{{ end }}{{ if .Prompt }}<|start_header_id|>user<|end_header_id|>\n\n{{ .Prompt }}<|eot_id|>{{ end }}<|start_header_id|>assistant<|end_header_id|>\n\n{{ .Response }}<|eot_id|>",
		Details: types.OllamaModelDetails{
			ParentModel:       "",
			Format:            "gguf",
			Family:            "llama",
			Families:          []string{"llama"},
			ParameterSize:     "8.0B",
			QuantizationLevel: "Q4_0",
		},
		ModelInfo: map[string]any{
			"general.architecture": "llama",
			"general.file_type":    2,
			"llama.context_length": 2000000,
		},
		Capabilities: []string{"completion", "vision", "tools", "thinking"},
	})
}

// Anthropic count tokens endpoint

func (s *Server) handleAnthropicCountTokens(w http.ResponseWriter, r *http.Request) {
	if !validateAnthropicHeaders(w, r) {
		return
	}

	body, ok := readBody(w, r, s.anthropicEnc)
	if !ok {
		return
	}
	var req types.AnthropicCountTokensRequest
	if err := decodeJSON(body, &req); err != nil {
		codec.WriteAnthropicError(w, http.StatusBadRequest, "invalid_request_error", "Invalid JSON body")
		return
	}

	systemText, err := types.ParseSystemText(req.System)
	if err != nil {
		codec.WriteAnthropicError(w, http.StatusBadRequest, "invalid_request_error", err.Error())
		return
	}

	inputItems, err := transformAnthropicMessagesToResponsesInput(req.Messages)
	if err != nil {
		codec.WriteAnthropicError(w, http.StatusBadRequest, "invalid_request_error", err.Error())
		return
	}
	tools := transformAnthropicToolsToResponses(req.Tools)

	count := estimateResponsesInputTokens(systemText, inputItems, tools)
	codec.WriteJSON(w, http.StatusOK, types.AnthropicCountTokensResponse{InputTokens: count})
}

// --- helpers ---

func validateAnthropicHeaders(w http.ResponseWriter, r *http.Request) bool {
	if strings.TrimSpace(r.Header.Get("anthropic-version")) == "" {
		codec.WriteAnthropicError(w, http.StatusBadRequest, "invalid_request_error", "Missing required header: anthropic-version")
		return false
	}
	if !hasAnthropicAuthHeader(r) {
		codec.WriteAnthropicError(w, http.StatusUnauthorized, "authentication_error", "Missing auth header: provide x-api-key or Authorization")
		return false
	}
	return true
}

func firstNonEmpty(values ...string) string {
	for _, v := range values {
		if s := strings.TrimSpace(v); s != "" {
			return s
		}
	}
	return ""
}
